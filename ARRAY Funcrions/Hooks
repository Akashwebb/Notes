âœ… 1. useState
ðŸ‘‰ Stores local component state.

import React, { useState } from "react";
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </>
  );
}

ðŸ§  Explanation
Holds a value.
setCount updates it.
Causes re-render.

Use for:
forms
toggles
UI values



âœ… 2. useEffect
ðŸ‘‰ Runs side effects after render.

import React, { useEffect } from "react";
function Example() {
  useEffect(() => {
    console.log("Component mounted");

    return () => {
      console.log("Cleanup");
    };
  }, []);

  return <p>Hello</p>;
}

ðŸ§  Explanation
Runs after UI renders.
Cleanup runs on unmount.

Use for:
API calls
timers
subscriptions



âœ… 3. useContext
ðŸ‘‰ Reads values from Context.

const ThemeContext = React.createContext();
function Child() {
  const theme = React.useContext(ThemeContext);
  return <p>{theme}</p>;
}

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  );
}

ðŸ§  Explanation
Avoids prop drilling.
Shares global values.

Use for:
theme
auth
settings



âœ… 4. useRef
ðŸ‘‰ Stores mutable value without re-render.

import React, { useRef } from "react";
function Example() {
  const countRef = useRef(0);
  const increment = () => {
    countRef.current += 1;
    console.log(countRef.current);
  };
  return <button onClick={increment}>Click</button>;
}

ðŸ§  Explanation
current stores value.
Updating does NOT re-render.

Use for:
DOM/native refs
timers
locks



âœ… 5. useMemo
ðŸ‘‰ Memoizes computed values.

import React, { useMemo } from "react";
function Example({ a, b }) {
  const sum = useMemo(() => {
    console.log("Calculating...");
    return a + b;
  }, [a, b]);

  return <p>{sum}</p>;
}

ðŸ§  Explanation
Caches result.
Recomputes only when deps change.

Use for:
heavy calculations
derived data



âœ… 6. useCallback
ðŸ‘‰ Memoizes functions.

import React, { useCallback, useState } from "react";
function Example() {
  const [count, setCount] = useState(0);
  const increment = useCallback(() => {
    setCount(c => c + 1);
  }, []);
  return <button onClick={increment}>{count}</button>;
}

ðŸ§  Explanation
Keeps same function instance.
Prevents unnecessary re-renders.

Use for:
passing handlers
performance


âœ… 7. useReducer
ðŸ‘‰ Manages complex state.

function reducer(state, action) {
  switch (action.type) {
    case "inc":
      return { count: state.count + 1 };
    default:
      return state;
  }
}
function Example() {
  const [state, dispatch] = React.useReducer(reducer, { count: 0 });

  return (
    <button onClick={() => dispatch({ type: "inc" })}>
      {state.count}
    </button>
  );
}

ðŸ§  Explanation
Redux-like pattern.
Predictable updates.

Use for:
large forms
complex logic



âœ… 8. useLayoutEffect
ðŸ‘‰ Runs before paint.

import React, { useLayoutEffect } from "react";
function Example() {
  useLayoutEffect(() => {
    console.log("Runs before paint");
  }, []);
  return <p>Hello</p>;
}

ðŸ§  Explanation
Like useEffect but synchronous.

Use for:
measuring layout
animations



âœ… 9. useImperativeHandle
ðŸ‘‰ Exposes methods via ref.
const Input = React.forwardRef((props, ref) => {
  React.useImperativeHandle(ref, () => ({
    focus() {
      console.log("Focused");
    }
  }));

  return <input />;
});

function App() {
  const ref = React.useRef();
  return <Input ref={ref} />;
}

ðŸ§  Explanation
Lets parent control child.
Use for:
focus
scroll
reset



âœ… 10. useDebugValue
ðŸ‘‰ Labels custom hooks.
function useOnline(status) {
  React.useDebugValue(status ? "Online" : "Offline");
  return status;
}

ðŸ§  Explanation
Shows value in DevTools.

Use for:
debugging custom hooks.



âœ… 11. useId
ðŸ‘‰ Generates unique IDs.
function Example() {
  const id = React.useId();
  return <label htmlFor={id}>Name</label>;
}

ðŸ§  Explanation
Safe for SSR.

Use for:
accessibility
forms



âœ… 12. useDeferredValue
ðŸ‘‰ Defers updates.
function Example({ value }) {
  const deferred = React.useDeferredValue(value);
  return <p>{deferred}</p>;
}

ðŸ§  Explanation
Keeps UI responsive.
Use for:
large lists
search


âœ… 13. useTransition
ðŸ‘‰ Marks updates as non-urgent.
function Example() {
  const [isPending, startTransition] = React.useTransition();
  const [count, setCount] = React.useState(0);
  return (
    <button onClick={() => {
      startTransition(() => setCount(c => c + 1));
    }}>
      {count}
    </button>
  );
}

ðŸ§  Explanation
Avoids blocking UI.

Use for:
heavy renders


âœ… 14. useSyncExternalStore
ðŸ‘‰ Subscribes to external store.
const store = {
  value: 0,
  subscribe(cb) { return () => {}; },
  getSnapshot() { return this.value; }
};

function Example() {
  const value = React.useSyncExternalStore(
    store.subscribe,
    store.getSnapshot
  );

  return <p>{value}</p>;
}

ðŸ§  Explanation

For libraries.
Safe external state.

âœ… Rules of Hooks (Important)
âœ” Call hooks at top level
âœ” Call hooks inside React components
âœ” No hooks in loops or conditions

âœ… Most Used in Real Apps
useState
useEffect
useRef
useContext
useCallback
useMemo


Everything else is advanced.

% 1. Spread Operator :
=>> The JavaScript spread operator (...) allows us to quickly copy all or part of an existing array or object 
    into another array or object.

// copy from one array to another
let x=[1,2,3]
let y=[...x,6,7]
console.log(y)     //  [1,2,3,6,7]

// copy from array to object
let x=[1,2,3,4]
let z={...x}
console.log(z)           //  { '0': 1, '1': 2, '2': 3, '3': 4 }

// copy a part of array and diaplay
let x=[1,2,3,4,5,6,7]
let z=[one,two ,...y]=x
console.log(y)            //  [ 3, 4, 5, 6, 7 ]

---------------------------------------------------------------------------------------------------------------------

% 2.  Destructing :: 
=>> We may have an array or object that we are working with, but we only need some of the items contained in these.
    Destructuring makes it easy to extract only what is needed.

const vehicles = ['mustang', 'f-150', 'expedition'];

// old way
const car = vehicles[0];
const truck = vehicles[1];
const suv = vehicles[2];

// With destructuring:
const [car, truck, suv] = vehicles;

------------------------------------------------------------------------------------------------------

% 3. Map Function :: 
=>> One of the most useful in React is the .map() array method.
    The .map() method allows you to **RUN A FUNCTION on each item in the array, returning a NEW ARRAY as the result.

------------------------------------------------------------------------------------------------------------

ğŸ”¹ Shallow Copy

A shallow copy "COPIES ONLY FIRST LEVEL OF ARRAY OR OBJECT" , NOT next level 
If the object has nested objects, they still share the same reference AND THEY ARE NOT COPIED

Example
const original = {
  name: 'Akash',                   // first level
  address: { city: 'Delhi' }       // secord level 
};
const shallow = { ...original };        // shallow copy
shallow.address.city = 'Mumbai';
console.log(original.address.city);     // âŒ Mumbai (changed!)

Because address is not copied, only the reference is. 

ğŸ”¹ Deep Copy

A deep copy copies all levels, including nested objects.
No shared references â†’ changes donâ€™t affect the original.

Example
const original = {
  name: 'Akash',
  address: { city: 'Delhi' }
};
const deep = JSON.parse(JSON.stringify(original));
deep.address.city = 'Mumbai';

console.log(original.address.city); // âœ… Delhi (unchanged)

--------------------------------------------------------------------------------------------------------------------

1ï¸âƒ£ What is a Higher-Order Function (HOF)?

A Higher-Order Function is a function that does at least one of the following:
@ Takes another function as an argument, or
@ Returns a function

âœ… Examples of Higher-Order Functions
map()
filter()
reduce()
setTimeout()
addEventListener()

Because they accept functions (callbacks).

âœ… How map() is a Higher-Order Function
Example
const numbers = [1, 2, 3];
const doubled = numbers.map(num => num * 2);

What is happening internally?
map receives a function
That function is executed for each element
num => num * 2   // â† callback

âœ” map accepts a function
âœ” Therefore, map is a Higher-Order Function

--------------------------------------------------------------------------------------------------------------------------

1ï¸âƒ£ Two Important JSON Functions

JavaScript provides two core JSON functions:

ğŸ”¹ 1. JSON.stringify()   ğŸ‘‰ Converts a JavaScript object â†’ JSON string

Example  :: 
const user = { name: "Akash", age: 27 };
const jsonString = JSON.stringify(user);
Output   :: 
'{"name":"Akash","age":27}'

ğŸ”¹ 2. JSON.parse()     ğŸ‘‰ Converts a JSON string â†’ JavaScript object

Example  ::
const obj = JSON.parse(jsonString);
Output   :: 
{ name: "Akash", age: 27 }

ğŸ”¹  3. When JSON methods BECOME Higher-Order Functions 

JSON.stringify (replacer function)  
JSON.stringify(obj, (key, value) => value); 
âœ” Accepts a function 
âœ” Now it is a Higher-Order Function 

JSON.parse (reviver function) 
JSON.parse(jsonString, (key, value) => value); 
âœ” Accepts a function 
âœ” Now it is a Higher-Order Function

--------------------------------------------------------------------------------------------------------------------------

ğŸ”¥ What is React Query (TanStack Query)?

React Query is a server side state-management for React like API data, DB data
It fetches, caches, syncs, updates, and manages server data
so you donâ€™t have to do it manually with useEffect + useState.

ğŸ‘‰ Redux is NOT good for server data
ğŸ‘‰ React Query is NOT for UI state

" I use React Query for server state.
ğŸ‘‰ useQuery handles fetching, caching, loading, and error states automatically.
ğŸ‘‰ useMutation is used for is used for POST, PUT, DELETE operations.
After a mutation, I use ( queryClient.invalidateQueries(['users']); )
ğŸ‘‰ invalidateQueries so React Query refetches the updated data.
This removes the need for manual useEffect and API state handling.â€

// main.jsx or index.js
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
const queryClient = new QueryClient();
root.render(
  <QueryClientProvider client={queryClient}>
    <App />
  </QueryClientProvider>
);

1. QueryClient is the central cache manager that controls all queries and mutations.
2. QueryClientProvider injects the QueryClient into Reactâ€™s context so all components can access cached data

QueryClient
   â†“
QueryClientProvider
   â†“
useQuery â†’ fetch + cache data
useMutation â†’ change data
useQueryClient â†’ refresh cache

â€œReact Query uses QueryClient as a central cache manager.
QueryClientProvider makes it available to the app.
useQuery is used to fetch and cache server data.
useMutation is used to modify data.
After mutation, we use useQueryClient to invalidate or refetch queries so UI stays in sync.â€

-------------------------------------------------------------------------------------------------------------------------------------

% 1. Spread Operator :
=>> The JavaScript spread operator (...) allows us to quickly copy all or part of an existing array or object 
    into another array or object.

// copy from one array to another
let x=[1,2,3]
let y=[...x,6,7]
console.log(y)     //  [1,2,3,6,7]

// copy from array to object
let x=[1,2,3,4]
let z={...x}
console.log(z)           //  { '0': 1, '1': 2, '2': 3, '3': 4 }

// copy a part of array and diaplay
let x=[1,2,3,4,5,6,7]
let z=[one,two ,...y]=x
console.log(y)            //  [ 3, 4, 5, 6, 7 ]

---------------------------------------------------------------------------------------------------------------------

% 2.  Destructing :: 
=>> We may have an array or object that we are working with, but we only need some of the items contained in these.
    Destructuring makes it easy to extract only what is needed.

const vehicles = ['mustang', 'f-150', 'expedition'];

// old way
const car = vehicles[0];
const truck = vehicles[1];
const suv = vehicles[2];

// With destructuring:
const [car, truck, suv] = vehicles;

------------------------------------------------------------------------------------------------------

% 3. Map Function :: 
=>> One of the most useful in React is the .map() array method.
    The .map() method allows you to **RUN A FUNCTION on each item in the array, returning a NEW ARRAY as the result.

------------------------------------------------------------------------------------------------------------

ðŸ”¹ Shallow Copy

A shallow copy "COPIES ONLY FIRST LEVEL OF ARRAY OR OBJECT" , NOT next level 
If the object has nested objects, they still share the same reference AND THEY ARE NOT COPIED

Example
const original = {
  name: 'Akash',                   // first level
  address: { city: 'Delhi' }       // secord level 
};
const shallow = { ...original };        // shallow copy
shallow.address.city = 'Mumbai';
console.log(original.address.city);     // âŒ Mumbai (changed!)

Because address is not copied, only the reference is. 

ðŸ”¹ Deep Copy

A deep copy copies all levels, including nested objects.
No shared references â†’ changes donâ€™t affect the original.

Example
const original = {
  name: 'Akash',
  address: { city: 'Delhi' }
};
const deep = JSON.parse(JSON.stringify(original));
deep.address.city = 'Mumbai';

console.log(original.address.city); // âœ… Delhi (unchanged)

--------------------------------------------------------------------------------------------------------------------

1ï¸âƒ£ What is a Higher-Order Function (HOF)?

A Higher-Order Function is a function that does at least one of the following:
@ Takes another function as an argument, or
@ Returns a function

âœ… Examples of Higher-Order Functions
map()
filter()
reduce()
setTimeout()
addEventListener()

Because they accept functions (callbacks).

âœ… How map() is a Higher-Order Function
Example
const numbers = [1, 2, 3];
const doubled = numbers.map(num => num * 2);

What is happening internally?
map receives a function
That function is executed for each element
num => num * 2   // â† callback

âœ” map accepts a function
âœ” Therefore, map is a Higher-Order Function

--------------------------------------------------------------------------------------------------------------------------

1ï¸âƒ£ Two Important JSON Functions

JavaScript provides two core JSON functions:

ðŸ”¹ 1. JSON.stringify()   ðŸ‘‰ Converts a JavaScript object â†’ JSON string

Example  :: 
const user = { name: "Akash", age: 27 };
const jsonString = JSON.stringify(user);
Output   :: 
'{"name":"Akash","age":27}'

ðŸ”¹ 2. JSON.parse()     ðŸ‘‰ Converts a JSON string â†’ JavaScript object

Example  ::
const obj = JSON.parse(jsonString);
Output   :: 
{ name: "Akash", age: 27 }

ðŸ”¹  3. When JSON methods BECOME Higher-Order Functions 

JSON.stringify (replacer function)  
JSON.stringify(obj, (key, value) => value); 
âœ” Accepts a function 
âœ” Now it is a Higher-Order Function 

JSON.parse (reviver function) 
JSON.parse(jsonString, (key, value) => value); 
âœ” Accepts a function 
âœ” Now it is a Higher-Order Function

